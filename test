import os
import sys
import re
import logging
import ctypes
import time
from pathlib import Path
from logging.handlers import RotatingFileHandler
from send2trash import send2trash
from typing import Set, List, Tuple

# =============  新增：rich 引入  =============
from rich.console import Console
from rich.table import Table
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.panel import Panel
from rich.text import Text
from rich import box

console = Console()
# ============================================

# ================= 配置 =================
class Config:
    WHITELIST_REGEX = re.compile(
        r'(desktop\.ini|thumbs\.db|'
        r'node_modules|\.git|\.?venv|env|'
        r'(windows|winsxs|system32|boot|intel|amd|nvidia)[\\/]|'
        r'system volume information|'
        r'\$recycle\.bin|'
        r'appdata|program files|'
        r'perflogs|msocache)',
        re.IGNORECASE
    )
    TEMP_EXTENSIONS = {'.tmp', '.temp', '.download', '.crdownload',
                       '.part', '.partial', '.dmp', '.log', '.bak'}
    MAX_DIR_DEPTH = 20
    LOG_FILE = 'cleaner.log'
    LOG_MAX_SIZE = 5 * 1024 * 1024
    LOG_BACKUP_COUNT = 3

# ============= 日志初始化（含 rich 彩色） =============
def init_logging(quiet: bool = False):
    class SensitiveFilter(logging.Filter):
        def filter(self, record):
            if hasattr(record, 'msg'):
                record.msg = str(record.msg).replace(os.getenv('USERNAME', ''), '***')
            return True

    file_handler = RotatingFileHandler(
        Config.LOG_FILE,
        maxBytes=Config.LOG_MAX_SIZE,
        backupCount=Config.LOG_BACKUP_COUNT,
        encoding='utf-8'
    )
    file_handler.addFilter(SensitiveFilter())
    file_handler.setFormatter(logging.Formatter('[%(asctime)s] %(levelname)s: %(message)s'))
    handlers = [file_handler]

    if not quiet:
        from rich.logging import RichHandler
        rh = RichHandler(console=console, show_path=False, rich_tracebacks=True)
        rh.addFilter(SensitiveFilter())
        handlers.append(rh)

    logging.basicConfig(level=logging.INFO, handlers=handlers)

# ============= 工具函数 =============
def is_admin() -> bool:
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False

def require_admin():
    if not is_admin():
        console.print('[red]此操作需要管理员权限[/red]')
        if ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, " ".join(sys.argv), None, 1) <= 32:
            console.print('[red]权限提升失败[/red]')
        sys.exit(1)

def is_whitelisted(path: Path) -> bool:
    return bool(Config.WHITELIST_REGEX.search(str(path)))

def is_resource_in_use(path: Path) -> bool:
    try:
        if path.is_file():
            try:
                fd = os.open(path, os.O_RDWR | os.O_EXCL | os.O_NOINHERIT)
                os.close(fd)
                return False
            except OSError:
                return True
        elif path.is_dir():
            test_file = path / f".test_{os.getpid()}"
            try:
                test_file.touch(exist_ok=False)
                test_file.unlink()
                return False
            except:
                return True
        return False
    except Exception:
        logging.exception(f"资源检查异常: {path}")
        return True

# ============= 安全删除（含大小统计） =============
def safe_delete(path: Path, preview: bool = True) -> Tuple[bool, int]:
    try:
        if is_whitelisted(path):
            console.print(f'[yellow]跳过[/yellow] 白名单: {path}')
            return False, 0
        if path.is_symlink():
            console.print(f'[cyan]跳过[/cyan] 符号链接: {path}')
            return False, 0
        if path.is_dir():
            dir_depth = len(str(path.resolve()).split(os.sep))
            if dir_depth > Config.MAX_DIR_DEPTH:
                console.print(f'[cyan]跳过[/cyan] 层级过深: {path}')
                return False, 0
        if is_resource_in_use(path):
            console.print(f'[magenta]跳过[/magenta] 占用中: {path}')
            return False, 0

        size = sum(f.stat().st_size for f in path.rglob('*') if f.is_file()) if path.is_dir() else (path.stat().st_size if path.is_file() else 0)
        if preview:
            console.print(f'[dim]预览[/dim] 将删除: {path}  ({size/1024:.1f} KB)')
            return False, 0
        send2trash(path)
        console.print(f'[red]删除[/red] {"目录" if path.is_dir() else "文件"}: {path}  ({size/1024:.1f} KB)')
        return True, size
    except Exception as e:
        console.print(f'[red]错误[/red] 删除失败: {path} - {e}')
        return False, 0

# ============= 获取系统临时目录 =============
def get_system_temp_dirs() -> List[Path]:
    temp_dirs = set()
    env_vars = ['TEMP', 'TMP', 'LOCALAPPDATA']
    for var in env_vars:
        if path_str := os.environ.get(var):
            try:
                path = Path(path_str).resolve()
                if path.exists() and os.access(path, os.R_OK | os.W_OK):
                    temp_dirs.add(path)
            except Exception:
                continue
    system_dirs = [
        Path(os.environ.get('SystemRoot', 'C:/Windows')) / 'Temp',
        Path('C:/Windows/Temp'),
        Path('C:/Windows/Logs'),
        Path('C:/Windows/Prefetch'),
    ]
    for dir_path in system_dirs:
        try:
            resolved = dir_path.resolve()
            if resolved.exists() and os.access(resolved, os.R_OK):
                temp_dirs.add(resolved)
        except Exception:
            continue
    return sorted(temp_dirs, key=lambda x: len(str(x)), reverse=True)

# ============= 清理函数（带进度条） =============
def clean_with_progress(name: str, paths: List[Path], preview: bool) -> int:
    total_size = 0
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        console=console
    ) as progress:
        task = progress.add_task(f"扫描 {name}...", total=None)
        for path in paths:
            if path.exists():
                for item in path.iterdir():
                    if item.is_file() and item.stat().st_ctime > (time.time() - 3600):
                        continue
                    ok, size = safe_delete(item, preview)
                    if ok:
                        total_size += size
            progress.advance(task)
    return total_size

def clean_temp(preview: bool = True) -> int:
    temp_dirs = get_system_temp_dirs()
    console.print(Panel(f"扫描 [cyan]{len(temp_dirs)}[/cyan] 个临时目录", title="临时文件"))
    return clean_with_progress("临时文件", temp_dirs, preview)

def get_browser_cache_paths() -> List[Path]:
    cache_paths = []
    user_profile = Path(os.environ.get('USERPROFILE', ''))
    if not user_profile.exists():
        return cache_paths
    browsers = {
        'Chrome': [
            'AppData/Local/Google/Chrome/User Data/*/Cache',
            'AppData/Local/Google/Chrome/User Data/*/CacheStorage',
            'AppData/Local/Google/Chrome/User Data/*/Service Worker/CacheStorage',
        ],
        'Edge': [
            'AppData/Local/Microsoft/Edge/User Data/*/Cache',
            'AppData/Local/Microsoft/Edge/User Data/*/CacheStorage',
            'AppData/Local/Microsoft/Edge/User Data/*/Service Worker/CacheStorage',
        ],
        'Firefox': [
            'AppData/Local/Mozilla/Firefox/Profiles/*/cache2',
            'AppData/Local/Mozilla/Firefox/Profiles/*/thumbnails',
        ],
        'Brave': [
            'AppData/Local/BraveSoftware/Brave-Browser/User Data/*/Cache',
            'AppData/Local/BraveSoftware/Brave-Browser/User Data/*/CacheStorage',
        ],
        'Opera': [
            'AppData/Roaming/Opera Software/Opera Stable/Cache',
            'AppData/Roaming/Opera Software/Opera Stable/Service Worker/CacheStorage',
        ]
    }
    for browser, patterns in browsers.items():
        for pattern in patterns:
            try:
                for path in user_profile.glob(pattern):
                    if path.is_dir():
                        cache_paths.append(path)
            except Exception as e:
                logging.warning(f'获取{browser}缓存路径失败: {e}')
    return cache_paths

def clean_browser_cache(preview: bool = True) -> int:
    cache_paths = get_browser_cache_paths()
    console.print(Panel(f"找到 [cyan]{len(cache_paths)}[/cyan] 个浏览器缓存目录", title="浏览器缓存"))
    return clean_with_progress("浏览器缓存", cache_paths, preview)

def clean_recycle_bin(preview: bool = True) -> int:
    if preview:
        console.print("[dim]预览[/dim] 将清空回收站")
        return 0
    try:
        winshell.recycle_bin().empty(confirm=False, show_progress=False, sound=False)
        console.print("[red]已清空[/red] 回收站")
        return 1
    except Exception as e:
        console.print(f"[red]错误[/red] 清空回收站失败: {e}")
        return 0

def clean_downloads(preview: bool = True) -> int:
    downloads_path = Path.home() / 'Downloads'
    if not downloads_path.exists():
        return 0
    console.print(Panel(f"扫描下载目录: [cyan]{downloads_path}[/cyan]", title="下载目录"))
    total_size = 0
    for item in downloads_path.iterdir():
        if item.suffix.lower() in Config.TEMP_EXTENSIONS or (item.is_dir() and not any(item.iterdir())):
            ok, size = safe_delete(item, preview)
            if ok:
                total_size += size
    return total_size

# ============= 主程序 =============
def main(preview: bool = True, quiet: bool = False):
    console.print(Panel("Windows 垃圾清理工具 (安全增强版)", style="bold green"))
    start_time = time.time()

    if not preview and not is_admin():
        require_admin()

    if not preview:
        if not quiet:
            confirm = console.input('[bold red]⚠️  确认实际删除文件? (y/n): [/]')
            if confirm.lower() != 'y':
                console.print("[yellow]操作已取消[/yellow]")
                return

    total_size = 0
    total_size += clean_temp(preview)
    total_size += clean_browser_cache(preview)
    total_size += clean_recycle_bin(preview)
    total_size += clean_downloads(preview)

    elapsed = time.time() - start_time
    table = Table(title="清理结果", box=box.SIMPLE_HEAVY)
    table.add_column("项目", style="cyan")
    table.add_column("值", style="magenta")
    table.add_row("释放空间", f"{total_size/1024/1024:.2f} MB")
    table.add_row("耗时", f"{elapsed:.2f} 秒")
    console.print(table)

if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(description='Windows 垃圾清理工具 (安全增强版)')
    parser.add_argument('--run', action='store_true', help='真正执行清理（默认仅预览）')
    parser.add_argument('--debug', action='store_true', help='启用调试日志')
    parser.add_argument('--quiet', action='store_true', help='静默模式（无终端输出，只写日志）')
    args = parser.parse_args()

    init_logging(quiet=args.quiet)
    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)

    if not args.run and not args.quiet:
        console.print('\n[dim]运行在预览模式（不会实际删除文件）[/dim]')
        console.print('[dim]使用 --run 参数执行实际删除操作[/dim]\n')

    try:
        main(preview=not args.run, quiet=args.quiet)
    except KeyboardInterrupt:
        console.print('\n[yellow]操作已取消[/yellow]')
        sys.exit(0)
    except Exception as e:
        console.print_exception()
        sys.exit(1)
