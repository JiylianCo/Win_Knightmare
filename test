import os
import sys
import logging
import ctypes
import winshell
import shutil
from pathlib import Path
from send2trash import send2trash

# 配置日志系统
logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] %(levelname)s: %(message)s',
    handlers=[
        logging.FileHandler('cleaner.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)

# 增强版白名单（小写统一）
WHITELIST = {
    'desktop.ini', 'thumbs.db', 
    'node_modules', '.git', '.venv', 'venv', 'env',
    'winsxs', 'system32', 'system volume information', 
    '$recycle.bin', 'appdata', 'program files', 'windows',
    'boot', 'intel', 'amd', 'nvidia', 'perflogs', 'msocache'
}

def is_admin():
    """检查是否以管理员权限运行"""
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False

def is_resource_in_use(path):
    """检查文件或目录是否被占用"""
    try:
        # 文件占用检查
        if path.is_file():
            with open(path, 'a', encoding='utf-8'):
                pass
            return False
        
        # 目录占用检查 - 尝试重命名测试
        if path.is_dir():
            test_rename = path.with_name(f"{path.name}_temp_test")
            path.rename(test_rename)
            test_rename.rename(path)
            return False
            
        return False
    except (OSError, PermissionError):
        return True  # 资源被占用或权限不足
    except Exception:
        return False

def safe_delete(path: Path, preview: bool = True):
    """
    安全删除文件或文件夹
    :param path: 待删除路径
    :param preview: True=仅打印，False=真正删除
    """
    try:
        # 检查白名单（不区分大小写）
        path_lower = str(path).lower()
        if any(protected in path_lower for protected in WHITELIST):
            logging.info(f'[跳过] 白名单: {path}')
            return
            
        # 检查资源是否被占用
        if is_resource_in_use(path):
            logging.warning(f'[跳过] 资源被占用: {path}')
            return
            
        # 预览模式只记录不删除
        if preview:
            logging.info(f'[预览] 将删除: {path}')
            return
            
        # 实际删除操作
        send2trash(path)
        logging.info(f'[删除] {"目录" if path.is_dir() else "文件"}: {path}')
        
    except Exception as e:
        logging.error(f'[错误] 删除失败: {path} - {str(e)}')

def get_system_temp_dirs():
    """获取系统所有可能的临时目录"""
    temp_dirs = []
    
    # 标准环境变量
    env_vars = ['TEMP', 'TMP', 'LOCALAPPDATA']
    for var in env_vars:
        if path := os.environ.get(var):
            temp_dirs.append(Path(path))
    
    # 常见系统临时目录
    system_dirs = [
        Path('C:/Windows/Temp'),
        Path('C:/Windows/Logs'),
        Path('C:/Windows/Prefetch'),
        Path(os.environ.get('SystemRoot', 'C:/Windows')) / 'Temp',
    ]
    
    # 用户特定临时目录
    user_profile = Path(os.environ.get('USERPROFILE', ''))
    if user_profile.exists():
        temp_dirs.extend([
            user_profile / 'AppData/Local/Temp',
            user_profile / 'AppData/Local/Microsoft/Windows/INetCache',
            user_profile / 'AppData/Local/Microsoft/Windows/INetCookies',
            user_profile / 'AppData/Local/Microsoft/Windows/History'
        ])
    
    # 过滤并去重
    return list(set(p.resolve() for p in temp_dirs if p.exists()))

def clean_temp(preview: bool = True):
    """清理系统临时文件"""
    temp_dirs = get_system_temp_dirs()
    
    logging.info(f'扫描 {len(temp_dirs)} 个临时目录')
    
    for temp_dir in temp_dirs:
        try:
            logging.info(f'扫描临时目录: {temp_dir}')
            for item in temp_dir.iterdir():
                # 排除关键系统目录
                if any(protected in item.name.lower() for protected in ['winsxs', 'system32']):
                    continue
                    
                # 跳过新创建的文件（最近1小时）
                if item.stat().st_ctime > (time.time() - 3600):
                    logging.debug(f'跳过新文件: {item} (创建时间: {time.ctime(item.stat().st_ctime)})')
                    continue
                    
                safe_delete(item, preview=preview)
        except PermissionError as e:
            logging.warning(f'[警告] 访问临时目录被拒绝: {temp_dir} - {e}')
        except Exception as e:
            logging.error(f'[错误] 清理临时目录失败: {temp_dir} - {e}')

def get_browser_cache_paths():
    """获取所有浏览器缓存路径"""
    cache_paths = []
    user_profile = Path(os.environ.get('USERPROFILE', ''))
    
    if not user_profile.exists():
        return cache_paths
    
    # 支持的浏览器列表
    browsers = {
        'Chrome': [
            'AppData/Local/Google/Chrome/User Data/*/Cache',
            'AppData/Local/Google/Chrome/User Data/*/CacheStorage',
            'AppData/Local/Google/Chrome/User Data/*/Service Worker/CacheStorage',
        ],
        'Edge': [
            'AppData/Local/Microsoft/Edge/User Data/*/Cache',
            'AppData/Local/Microsoft/Edge/User Data/*/CacheStorage',
            'AppData/Local/Microsoft/Edge/User Data/*/Service Worker/CacheStorage',
        ],
        'Firefox': [
            'AppData/Local/Mozilla/Firefox/Profiles/*/cache2',
            'AppData/Local/Mozilla/Firefox/Profiles/*/thumbnails',
        ],
        'Brave': [
            'AppData/Local/BraveSoftware/Brave-Browser/User Data/*/Cache',
            'AppData/Local/BraveSoftware/Brave-Browser/User Data/*/CacheStorage',
        ]
    }
    
    # 构建路径模式
    for browser, patterns in browsers.items():
        for pattern in patterns:
            for path in user_profile.glob(pattern):
                if path.is_dir():
                    cache_paths.append(path)
    
    return cache_paths

def clean_browser_cache(preview: bool = True):
    """清理浏览器缓存"""
    cache_paths = get_browser_cache_paths()
    
    if not cache_paths:
        logging.info('未找到浏览器缓存目录')
        return
        
    logging.info(f'找到 {len(cache_paths)} 个浏览器缓存目录')
    
    for cache_dir in cache_paths:
        try:
            logging.info(f'清理缓存: {cache_dir}')
            for item in cache_dir.iterdir():
                safe_delete(item, preview=preview)
        except Exception as e:
            logging.error(f'[错误] 清理浏览器缓存失败: {cache_dir} - {e}')

def clean_recycle_bin(preview: bool = True):
    """安全清空回收站"""
    if preview:
        logging.info('[预览] 将清空回收站')
        return
        
    try:
        winshell.recycle_bin().empty(confirm=False, show_progress=False, sound=False)
        logging.info('[删除] 回收站已清空')
    except Exception as e:
        logging.error(f'[错误] 清空回收站失败: {str(e)}')

def clean_downloads(preview: bool = True):
    """清理下载目录中的临时文件"""
    downloads_path = Path.home() / 'Downloads'
    if not downloads_path.exists():
        return
        
    # 常见可删除的临时文件类型
    temp_extensions = {
        '.tmp', '.temp', '.download', '.crdownload', 
        '.part', '.partial', '.dmp', '.log', '.bak'
    }
    
    logging.info(f'扫描下载目录: {downloads_path}')
    
    for item in downloads_path.iterdir():
        # 删除特定扩展名的文件
        if item.suffix.lower() in temp_extensions:
            safe_delete(item, preview)
            
        # 删除空目录
        if item.is_dir() and not any(item.iterdir()):
            safe_delete(item, preview)

def main(preview: bool = True):
    """主清理函数"""
    logging.info('=== 开始清理 ===')
    
    # 检查管理员权限
    if not is_admin():
        logging.warning('⚠️ 警告: 未以管理员权限运行，部分操作可能受限')
    
    # 用户确认
    if not preview:
        confirm = input('⚠️ 警告: 这将实际删除文件! 确认继续? (y/n): ')
        if confirm.lower() != 'y':
            logging.info('操作已取消')
            return
    
    # 执行清理任务
    clean_temp(preview)
    clean_browser_cache(preview)
    clean_recycle_bin(preview)
    clean_downloads(preview)
    
    logging.info('=== 清理完成 ===')

if __name__ == '__main__':
    import argparse
    import time

    parser = argparse.ArgumentParser(description='Windows 垃圾清理工具')
    parser.add_argument('--run', action='store_true', help='真正执行清理（默认仅预览）')
    parser.add_argument('--debug', action='store_true', help='启用调试日志')
    args = parser.parse_args()

    # 设置调试日志级别
    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)
        logging.debug('调试模式已启用')

    # 安全提示
    if not args.run:
        print('\n⚠️ 运行在预览模式（不会实际删除文件）')
        print('⚠️ 使用 --run 参数执行实际删除操作\n')
    
    try:
        start_time = time.time()
        main(preview=not args.run)
        elapsed = time.time() - start_time
        logging.info(f'清理耗时: {elapsed:.2f}秒')
    except KeyboardInterrupt:
        logging.info('\n操作已取消')
        sys.exit(0)
    except Exception as e:
        logging.exception(f'程序发生严重错误: {str(e)}')
        sys.exit(1)
