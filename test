import os
import sys
import re
import logging
import ctypes
import winshell
import time
from pathlib import Path
from logging.handlers import RotatingFileHandler
from send2trash import send2trash
from typing import Set, List

# ==================== 配置部分 ====================
class Config:
    # 白名单
    WHITELIST_REGEX = re.compile(
        r'(desktop\.ini|thumbs\.db|'
        r'node_modules|\.git|\.?venv|env|'
        r'(windows|winsxs|system32|boot|intel|amd|nvidia)[\\/]|'
        r'system volume information|'
        r'\$recycle\.bin|'
        r'appdata|program files|'
        r'perflogs|msocache)',
        re.IGNORECASE
    )
    
    # 临时文件扩展名
    TEMP_EXTENSIONS = {'.tmp', '.temp', '.download', '.crdownload', 
                      '.part', '.partial', '.dmp', '.log', '.bak'}
    
    # 最大目录深度
    MAX_DIR_DEPTH = 20
    
    # 日志配置
    LOG_FILE = 'cleaner.log'
    LOG_MAX_SIZE = 5 * 1024 * 1024  # 5MB
    LOG_BACKUP_COUNT = 3

# 工具函数 
def init_logging():
    """安全日志初始化"""
    class SensitiveFilter(logging.Filter):
        def filter(self, record):
            if hasattr(record, 'msg'):
                record.msg = str(record.msg).replace(os.getenv('USERNAME', ''), '***')
            return True
            
    handlers = [
        RotatingFileHandler(
            Config.LOG_FILE,
            maxBytes=Config.LOG_MAX_SIZE,
            backupCount=Config.LOG_BACKUP_COUNT,
            encoding='utf-8'
        ),
        logging.StreamHandler()
    ]
    
    for handler in handlers:
        handler.addFilter(SensitiveFilter())
    
    logging.basicConfig(
        level=logging.INFO,
        format='[%(asctime)s] %(levelname)s: %(message)s',
        handlers=handlers
    )

def is_admin() -> bool:
    """检查是否以管理员权限运行"""
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False

def require_admin():
    """强制要求管理员权限"""
    if not is_admin():
        logging.error('此操作需要管理员权限')
        if ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, " ".join(sys.argv), None, 1) <= 32:
            logging.error('权限提升失败')
        sys.exit(1)

def is_whitelisted(path: Path) -> bool:
    """检查路径是否在白名单中"""
    # 使用Config.WHITELIST_REGEX正则表达式来匹配路径，如果匹配成功则返回True，否则返回False
    return bool(Config.WHITELIST_REGEX.search(str(path)))

#  核心功能 
def is_resource_in_use(path: Path) -> bool:
    """增强版资源占用检查"""
    try:
        if path.is_file():
            # 尝试获取文件独占锁
            try:
                fd = os.open(path, os.O_RDWR | os.O_EXCL | os.O_NOINHERIT)
                os.close(fd)
                return False
            except OSError as e:
                return True
                
        elif path.is_dir():
            # 尝试创建测试文件检查目录可写性
            test_file = path / f".test_{os.getpid()}"
            try:
                test_file.touch(exist_ok=False)
                test_file.unlink()
                return False
            except:
                return True
                
        return False
    except Exception:
        logging.exception(f"资源检查异常: {path}")
        return True  # 保守处理，视为占用

def safe_delete(path: Path, preview: bool = True) -> bool:
    """
    安全删除文件或文件夹
    :return: 是否执行了删除操作
    """
    try:
        # 检查白名单
        if is_whitelisted(path):
            logging.info(f'[跳过] 白名单: {path}')
            return False
            
        # 检查符号链接
        if path.is_symlink():
            logging.warning(f'[跳过] 符号链接: {path}')
            return False
            
        # 检查目录深度
        if path.is_dir():
            dir_depth = len(str(path.resolve()).split(os.sep))
            if dir_depth > Config.MAX_DIR_DEPTH:
                logging.warning(f'[跳过] 目录层级过深: {path}')
                return False
                
        # 检查资源占用
        if is_resource_in_use(path):
            logging.warning(f'[跳过] 资源被占用: {path}')
            return False
            
        # 预览模式
        if preview:
            logging.info(f'[预览] 将删除: {path}')
            return False
            
        # 实际删除
        send2trash(path)
        logging.info(f'[删除] {"目录" if path.is_dir() else "文件"}: {path}')
        return True
        
    except Exception as e:
        logging.error(f'[错误] 删除失败: {path} - {str(e)}')
        return False

def get_system_temp_dirs() -> List[Path]:
    """获取所有系统临时目录（安全版）"""
    temp_dirs = set()
    
    # 标准环境变量
    env_vars = ['TEMP', 'TMP', 'LOCALAPPDATA']
    for var in env_vars:
        if path_str := os.environ.get(var):
            try:
                path = Path(path_str).resolve()
                if path.exists() and os.access(path, os.R_OK | os.W_OK):
                    temp_dirs.add(path)
            except (OSError, RuntimeError):
                continue
    
    # 系统目录
    system_dirs = [
        Path(os.environ.get('SystemRoot', 'C:/Windows')) / 'Temp',
        Path('C:/Windows/Temp'),
        Path('C:/Windows/Logs'),
        Path('C:/Windows/Prefetch'),
    ]
    
    for dir_path in system_dirs:
        try:
            resolved = dir_path.resolve()
            if resolved.exists() and os.access(resolved, os.R_OK):
                temp_dirs.add(resolved)
        except (OSError, RuntimeError):
            continue
    
    return sorted(temp_dirs, key=lambda x: len(str(x)), reverse=True)

def clean_temp(preview: bool = True) -> int:
    """清理系统临时文件，返回删除的项目数"""
    deleted_count = 0
    temp_dirs = get_system_temp_dirs()
    
    logging.info(f'扫描 {len(temp_dirs)} 个临时目录')
    
    for temp_dir in temp_dirs:
        try:
            logging.info(f'扫描临时目录: {temp_dir}')
            for item in temp_dir.iterdir():
                # 跳过新创建的文件（最近1小时）
                if item.stat().st_ctime > (time.time() - 3600):
                    logging.debug(f'跳过新文件: {item} (创建时间: {time.ctime(item.stat().st_ctime)})')
                    continue
                    
                if safe_delete(item, preview):
                    deleted_count += 1
        except PermissionError as e:
            logging.warning(f'[警告] 访问临时目录被拒绝: {temp_dir} - {e}')
        except Exception as e:
            logging.error(f'[错误] 清理临时目录失败: {temp_dir} - {e}')
    
    return deleted_count

def get_browser_cache_paths() -> List[Path]:
    """获取所有浏览器缓存路径"""
    cache_paths = []
    user_profile = Path(os.environ.get('USERPROFILE', ''))
    
    if not user_profile.exists():
        return cache_paths
    
    # 支持的浏览器列表
    browsers = {
        'Chrome': [
            'AppData/Local/Google/Chrome/User Data/*/Cache',
            'AppData/Local/Google/Chrome/User Data/*/CacheStorage',
            'AppData/Local/Google/Chrome/User Data/*/Service Worker/CacheStorage',
        ],
        'Edge': [
            'AppData/Local/Microsoft/Edge/User Data/*/Cache',
            'AppData/Local/Microsoft/Edge/User Data/*/CacheStorage',
            'AppData/Local/Microsoft/Edge/User Data/*/Service Worker/CacheStorage',
        ],
        'Firefox': [
            'AppData/Local/Mozilla/Firefox/Profiles/*/cache2',
            'AppData/Local/Mozilla/Firefox/Profiles/*/thumbnails',
        ],
        'Brave': [
            'AppData/Local/BraveSoftware/Brave-Browser/User Data/*/Cache',
            'AppData/Local/BraveSoftware/Brave-Browser/User Data/*/CacheStorage',
        ],
        'Opera': [
            'AppData/Roaming/Opera Software/Opera Stable/Cache',
            'AppData/Roaming/Opera Software/Opera Stable/Service Worker/CacheStorage',
        ]
    }
    
    # 构建路径模式
    for browser, patterns in browsers.items():
        for pattern in patterns:
            try:
                for path in user_profile.glob(pattern):
                    if path.is_dir():
                        cache_paths.append(path)
            except Exception as e:
                logging.warning(f'获取{browser}缓存路径失败: {e}')
    
    return cache_paths

def clean_browser_cache(preview: bool = True) -> int:
    """清理浏览器缓存，返回删除的项目数"""
    deleted_count = 0
    cache_paths = get_browser_cache_paths()
    
    if not cache_paths:
        logging.info('未找到浏览器缓存目录')
        return 0
        
    logging.info(f'找到 {len(cache_paths)} 个浏览器缓存目录')
    
    for cache_dir in cache_paths:
        try:
            logging.info(f'清理缓存: {cache_dir}')
            for item in cache_dir.iterdir():
                if safe_delete(item, preview):
                    deleted_count += 1
        except Exception as e:
            logging.error(f'[错误] 清理浏览器缓存失败: {cache_dir} - {e}')
    
    return deleted_count

def clean_recycle_bin(preview: bool = True) -> bool:
    """安全清空回收站，返回是否执行了操作"""
    if preview:
        logging.info('[预览] 将清空回收站')
        return False
        
    try:
        winshell.recycle_bin().empty(confirm=False, show_progress=False, sound=False)
        logging.info('[删除] 回收站已清空')
        return True
    except Exception as e:
        logging.error(f'[错误] 清空回收站失败: {str(e)}')
        return False

def clean_downloads(preview: bool = True) -> int:
    """清理下载目录，返回删除的项目数"""
    deleted_count = 0
    downloads_path = Path.home() / 'Downloads'
    
    if not downloads_path.exists():
        return 0
        
    logging.info(f'扫描下载目录: {downloads_path}')
    
    for item in downloads_path.iterdir():
        # 删除特定扩展名的文件
        if item.suffix.lower() in Config.TEMP_EXTENSIONS:
            if safe_delete(item, preview):
                deleted_count += 1
                
        # 删除空目录
        if item.is_dir() and not any(item.iterdir()):
            if safe_delete(item, preview):
                deleted_count += 1
    
    return deleted_count

#  主程序 
def main(preview: bool = True):
    """主清理函数"""
    logging.info('=== 开始清理 ===')
    start_time = time.time()
    
    # 管理员权限检查
    if not preview and not is_admin():
        require_admin()
    
    # 用户确认
    if not preview:
        confirm = input('⚠️ 警告: 这将实际删除文件! 确认继续? (y/n): ')
        if confirm.lower() != 'y':
            logging.info('操作已取消')
            return
    
    # 执行清理任务
    total_deleted = 0
    total_deleted += clean_temp(preview)
    total_deleted += clean_browser_cache(preview)
    if clean_recycle_bin(preview):
        total_deleted += 1  # 回收站算作一个项目
    total_deleted += clean_downloads(preview)
    
    elapsed = time.time() - start_time
    logging.info(f'=== 清理完成 ===\n'
                 f'总操作项目: {total_deleted}\n'
                 f'耗时: {elapsed:.2f}秒')

if __name__ == '__main__':
    import argparse
    
    parser = argparse.ArgumentParser(description='Windows 垃圾清理工具 (安全增强版)')
    parser.add_argument('--run', action='store_true', help='真正执行清理（默认仅预览）')
    parser.add_argument('--debug', action='store_true', help='启用调试日志')
    args = parser.parse_args()

    # 初始化日志
    init_logging()
    
    # 设置调试日志级别
    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)
        logging.debug('调试模式已启用')

    # 安全提示
    if not args.run:
        print('\n⚠️ 运行在预览模式（不会实际删除文件）')
        print('⚠️ 使用 --run 参数执行实际删除操作\n')
    
    try:
        main(preview=not args.run)
    except KeyboardInterrupt:
        logging.info('\n操作已取消')
        sys.exit(0)
    except Exception as e:
        logging.exception(f'程序发生严重错误: {str(e)}')
        sys.exit(1)

