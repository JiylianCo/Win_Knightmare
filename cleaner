import os
import sys
import re
import logging
import ctypes
import time
import winshell
import json
import hashlib
from concurrent.futures import ThreadPoolExecutor, as_completed
from pathlib import Path
from logging.handlers import RotatingFileHandler
from send2trash import send2trash
from typing import Set, List, Tuple, Iterable, Optional, Dict

# ============= Rich 增强引入 =============
from rich.console import Console
from rich.table import Table
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TimeRemainingColumn
from rich.panel import Panel
from rich.text import Text
from rich import box
from rich.theme import Theme
from rich.columns import Columns
from rich.align import Align
from rich.style import Style
from rich.padding import Padding
from rich.rule import Rule
from rich.syntax import Syntax
from rich.markdown import Markdown

# 自定义主题
custom_theme = Theme({
    "success": "bold green",
    "warning": "bold yellow",
    "error": "bold red",
    "info": "bold blue",
    "header": "bold white on dark_blue",
    "highlight": "bold cyan",
    "progress": "bold magenta",
    "path": "bright_white",
    "size": "bright_cyan"
})
console = Console(theme=custom_theme)

def print_header(title: str):
    """美化标题输出"""
    console.print()
    console.print(Rule(title, style="header"), justify="center")
    console.print()

def print_section(title: str, content: str = ""):
    """美化分区输出"""
    console.print(Panel.fit(
        content,
        title=title,
        title_align="left",
        border_style="progress",
        padding=(1, 2)
    ))

def print_action(message: str, status: str = "info"):
    """美化操作状态输出"""
    icons = {
        "info": "ℹ️",
        "success": "✅",
        "warning": "⚠️",
        "error": "❌",
        "skip": "⏩"
    }
    console.print(f"{icons.get(status, '')} [{status}]{message}[/]")

def print_file_action(path: Path, action: str, size_mb: float = 0):
    """美化文件操作输出"""
    actions = {
        "delete": ("[red]删除[/red]", "❌"),
        "skip": ("[yellow]跳过[/yellow]", "⏩"),
        "preview": ("[dim]预览[/dim]", "👁️"),
        "error": ("[red]错误[/red]", "❗")
    }
    style, icon = actions.get(action, ("", ""))
    size_info = f"[size]{size_mb:.1f} MB[/]" if size_mb > 0 else ""
    console.print(
        f"{icon} {style} {action.capitalize():<7} "
        f"[path]{str(path)}[/] {size_info}"
    )

def print_summary_table(title: str, data: List[Tuple[str, str]]):
    """美化汇总表格输出"""
    table = Table(title=title, box=box.ROUNDED, show_header=False)
    table.add_column("Item", style="highlight", no_wrap=True)
    table.add_column("Value", style="info")
    for item, value in data:
        table.add_row(item, value)
    console.print(Padding(table, (1, 4)))

def print_progress_bar(description: str, total: int = None):
    """增强进度条样式"""
    return Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        BarColumn(complete_style="progress", finished_style="success"),
        TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
        TimeRemainingColumn(),
        console=console,
        expand=True
    )
# ======================================

# ================= 配置 =================
class Config:
    CONFIG_FILE = Path.home() / '.cleaner_config.json'
    
    # 默认配置
    DEFAULT_CONFIG = {
        "WHITELIST_REGEX": r'(desktop\.ini|thumbs\.db|node_modules|\.git|\.?venv|env|'
                          r'(windows|winsxs|system32|boot|intel|amd|nvidia)[\\/]|'
                          r'system volume information|\$recycle\.bin|'
                          r'appdata|program files|perflogs|msocache)',
        "TEMP_EXTENSIONS": ['.tmp', '.temp', '.download', '.crdownload',
                           '.part', '.partial', '.dmp', '.log', '.bak'],
        "MAX_DIR_DEPTH": 20,
        "LOG_FILE": str(Path.home() / 'cleaner.log'),
        "LOG_MAX_SIZE": 5 * 1024 * 1024,
        "LOG_BACKUP_COUNT": 3,
        "SAFETY_FILE_SIZE_MB": 100,
        "SYSTEM_FILE_SIGNATURES": {
            "notepad.exe": "a8c8d6e7d48e284d85f2c79a3929bd53",
            "explorer.exe": "1e3d6e6f0e3e4e5d6e7f8e9d0e1e2e3e4"
        },
        "THREAD_POOL_SIZE": 4,
        "EXCLUDE_RECENT_FILES_HOURS": 1
    }
    
    def __init__(self):
        self.load_config()
        
    def load_config(self):
        """从配置文件加载配置，不存在则使用默认配置"""
        try:
            if self.CONFIG_FILE.exists():
                with open(self.CONFIG_FILE, 'r', encoding='utf-8') as f:
                    user_config = json.load(f)
                    for key, value in user_config.items():
                        if key in self.DEFAULT_CONFIG:
                            self.DEFAULT_CONFIG[key] = value
        except Exception as e:
            logging.warning(f"加载配置文件失败: {e}")
            
        # 初始化配置属性
        self.WHITELIST_REGEX = re.compile(self.DEFAULT_CONFIG["WHITELIST_REGEX"], re.IGNORECASE)
        self.TEMP_EXTENSIONS = set(self.DEFAULT_CONFIG["TEMP_EXTENSIONS"])
        self.MAX_DIR_DEPTH = self.DEFAULT_CONFIG["MAX_DIR_DEPTH"]
        self.LOG_FILE = Path(self.DEFAULT_CONFIG["LOG_FILE"])
        self.LOG_MAX_SIZE = self.DEFAULT_CONFIG["LOG_MAX_SIZE"]
        self.LOG_BACKUP_COUNT = self.DEFAULT_CONFIG["LOG_BACKUP_COUNT"]
        self.SAFETY_FILE_SIZE_MB = self.DEFAULT_CONFIG["SAFETY_FILE_SIZE_MB"]
        self.SYSTEM_FILE_SIGNATURES = self.DEFAULT_CONFIG["SYSTEM_FILE_SIGNATURES"]
        self.THREAD_POOL_SIZE = self.DEFAULT_CONFIG["THREAD_POOL_SIZE"]
        self.EXCLUDE_RECENT_FILES_HOURS = self.DEFAULT_CONFIG["EXCLUDE_RECENT_FILES_HOURS"]

config = Config()

# ============= 日志初始化 =============
def init_logging(quiet: bool = False):
    class SensitiveFilter(logging.Filter):
        def filter(self, record):
            if hasattr(record, 'msg'):
                record.msg = str(record.msg).replace(os.getenv('USERNAME', ''), '***')
            return True

    file_handler = RotatingFileHandler(
        config.LOG_FILE,
        maxBytes=config.LOG_MAX_SIZE,
        backupCount=config.LOG_BACKUP_COUNT,
        encoding='utf-8'
    )
    file_handler.addFilter(SensitiveFilter())
    file_handler.setFormatter(logging.Formatter('[%(asctime)s] %(levelname)s: %(message)s'))
    handlers = [file_handler]

    if not quiet:
        from rich.logging import RichHandler
        rh = RichHandler(console=console, show_path=False, rich_tracebacks=True)
        rh.addFilter(SensitiveFilter())
        handlers.append(rh)

    logging.basicConfig(level=logging.INFO, handlers=handlers)

# ============= 安全工具函数 =============
def is_admin() -> bool:
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False

def require_admin():
    if not is_admin():
        print_header("权限警告")
        print_section("需要管理员权限", "此操作需要管理员权限才能继续")
        params = " ".join(f'"{arg}"' for arg in sys.argv)
        if ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, params, None, 1) <= 32:
            print_action("权限提升失败", "error")
        sys.exit(1)

def is_safe_path(path: Path) -> bool:
    """检查路径是否安全（防止路径遍历）"""
    try:
        path.resolve().relative_to(Path.cwd())
        return True
    except ValueError:
        return False

def is_whitelisted(path: Path) -> bool:
    """检查路径是否在白名单中"""
    if not is_safe_path(path):
        return True
    return bool(config.WHITELIST_REGEX.search(str(path)))

def is_system_file(path: Path) -> bool:
    """检查是否是受保护的系统文件"""
    if not path.is_file():
        return False
        
    try:
        file_name = path.name.lower()
        if file_name in config.SYSTEM_FILE_SIGNATURES:
            with open(path, 'rb') as f:
                file_hash = hashlib.md5(f.read()).hexdigest()
            return file_hash == config.SYSTEM_FILE_SIGNATURES[file_name]
        return False
    except Exception:
        logging.exception(f"系统文件检查异常: {path}")
        return True

def is_hardlink(path: Path) -> bool:
    """检查是否是硬链接"""
    try:
        return path.is_file() and path.stat().st_nlink > 1
    except Exception:
        logging.exception(f"硬链接检查异常: {path}")
        return False

def is_resource_in_use(path: Path) -> bool:
    """检查资源是否被占用"""
    try:
        if not is_safe_path(path):
            return True
            
        if path.is_file():
            try:
                fd = os.open(path, os.O_RDWR | os.O_EXCL | os.O_NOINHERIT)
                os.close(fd)
                return False
            except OSError:
                return True
        elif path.is_dir():
            test_file = path / f".test_{os.getpid()}"
            try:
                test_file.touch(exist_ok=False)
                test_file.unlink()
                return False
            except:
                return True
        return False
    except Exception:
        logging.exception(f"资源检查异常: {path}")
        return True

def calculate_size(path: Path) -> int:
    """高效计算文件或目录大小（多线程优化）"""
    if not is_safe_path(path):
        return 0
        
    if path.is_file():
        return path.stat().st_size if not is_hardlink(path) else 0
        
    total = 0
    with ThreadPoolExecutor(max_workers=config.THREAD_POOL_SIZE) as executor:
        futures = []
        for root, _, files in os.walk(path):
            for file in files:
                file_path = Path(root) / file
                futures.append(executor.submit(
                    lambda p: p.stat().st_size if p.is_file() and not is_hardlink(p) else 0,
                    file_path
                ))
        
        for future in as_completed(futures):
            total += future.result()
            
    return total

def confirm_large_file(path: Path, size_mb: float) -> bool:
    """大文件二次确认"""
    if size_mb < config.SAFETY_FILE_SIZE_MB:
        return True
    
    print_header("大文件警告")
    print_section(
        "检测到大文件",
        f"路径: [path]{path}[/]\n大小: [size]{size_mb:.1f} MB[/]"
    )
    confirm = console.input('[bold red]⚠️  确认删除此大文件? (y/n): [/]')
    return confirm.lower() == 'y'

# ============= 安全删除 =============
def safe_delete(path: Path, preview: bool = True) -> Tuple[bool, int]:
    try:
        # 安全检查
        if not is_safe_path(path):
            print_file_action(path, "skip")
            return False, 0
            
        if is_whitelisted(path):
            print_file_action(path, "skip")
            return False, 0
            
        if is_system_file(path):
            print_file_action(path, "skip")
            return False, 0
            
        if path.is_symlink() or is_hardlink(path):
            print_file_action(path, "skip")
            return False, 0
            
        if path.is_dir():
            dir_depth = len(str(path.resolve()).split(os.sep))
            if dir_depth > config.MAX_DIR_DEPTH:
                print_file_action(path, "skip")
                return False, 0
                
        if is_resource_in_use(path):
            print_file_action(path, "skip")
            return False, 0

        # 计算大小
        size = calculate_size(path)
        size_mb = size / 1024 / 1024
        
        if preview:
            print_file_action(path, "preview", size_mb)
            return False, 0
            
        # 大文件二次确认
        if size_mb >= config.SAFETY_FILE_SIZE_MB:
            if not confirm_large_file(path, size_mb):
                print_file_action(path, "skip")
                return False, 0
                
        # 执行删除
        send2trash(path)
        print_file_action(path, "delete", size_mb)
        return True, size
    except Exception as e:
        print_file_action(path, "error")
        logging.exception(f"删除失败: {path}")
        return False, 0

# ============= 清理功能 =============
def get_system_temp_dirs() -> List[Path]:
    """获取系统临时目录（增强安全性）"""
    temp_dirs = set()
    env_vars = ['TEMP', 'TMP', 'LOCALAPPDATA']
    
    for var in env_vars:
        if path_str := os.environ.get(var):
            try:
                path = Path(path_str).resolve()
                if path.exists() and os.access(path, os.R_OK | os.W_OK) and is_safe_path(path):
                    temp_dirs.add(path)
            except Exception:
                continue
                
    system_dirs = [
        Path(os.environ.get('SystemRoot', 'C:/Windows')) / 'Temp',
        Path('C:/Windows/Temp'),
        Path('C:/Windows/Logs'),
        Path('C:/Windows/Prefetch'),
    ]
    
    for dir_path in system_dirs:
        try:
            resolved = dir_path.resolve()
            if resolved.exists() and os.access(resolved, os.R_OK) and is_safe_path(resolved):
                temp_dirs.add(resolved)
        except Exception:
            continue
            
    return sorted(temp_dirs, key=lambda x: len(str(x)), reverse=True)

def clean_temp(preview: bool = True) -> int:
    """清理临时文件（美化输出）"""
    print_header("清理临时文件")
    temp_dirs = get_system_temp_dirs()
    
    if not temp_dirs:
        print_action("未找到可清理的临时目录", "warning")
        return 0
    
    print_section("扫描目录", "\n".join(f"• [path]{d}[/]" for d in temp_dirs))
    
    total_size = 0
    with print_progress_bar("扫描临时文件...") as progress:
        task = progress.add_task("清理中...", total=len(temp_dirs))
        for temp_dir in temp_dirs:
            if temp_dir.exists():
                for item in temp_dir.iterdir():
                    # 跳过最近创建的文件
                    recent_threshold = time.time() - config.EXCLUDE_RECENT_FILES_HOURS * 3600
                    if (item.is_file() or item.is_dir()) and item.stat().st_ctime > recent_threshold:
                        continue
                        
                    ok, size = safe_delete(item, preview)
                    if ok:
                        total_size += size
            progress.advance(task)
    
    size_mb = total_size / 1024 / 1024
    print_summary_table("临时文件清理结果", [
        ("扫描目录数", str(len(temp_dirs))),
        ("释放空间", f"{size_mb:.2f} MB"),
        ("模式", "预览" if preview else "实际执行")
    ])
    return total_size

def clean_browser_cache(preview: bool = True) -> int:
    """清理浏览器缓存（美化输出）"""
    print_header("清理浏览器缓存")
    browsers = {
        "Chrome": Path(os.environ.get('LOCALAPPDATA', '')) / 'Google' / 'Chrome' / 'User Data' / 'Default' / 'Cache',
        "Edge": Path(os.environ.get('LOCALAPPDATA', '')) / 'Microsoft' / 'Edge' / 'User Data' / 'Default' / 'Cache',
        "Firefox": Path(os.environ.get('LOCALAPPDATA', '')) / 'Mozilla' / 'Firefox' / 'Profiles'
    }
    
    valid_browsers = {}
    for name, path in browsers.items():
        if path.exists():
            valid_browsers[name] = path
    
    if not valid_browsers:
        print_action("未找到浏览器缓存目录", "warning")
        return 0
    
    print_section("检测到的浏览器", "\n".join(
        f"• {name}: [path]{path}[/]" for name, path in valid_browsers.items()
    ))
    
    total_size = 0
    with print_progress_bar("扫描浏览器缓存...") as progress:
        task = progress.add_task("清理中...", total=len(valid_browsers))
        for name, cache_dir in valid_browsers.items():
            if cache_dir.exists():
                for item in cache_dir.iterdir():
                    ok, size = safe_delete(item, preview)
                    if ok:
                        total_size += size
            progress.advance(task)
    
    size_mb = total_size / 1024 / 1024
    print_summary_table("浏览器缓存清理结果", [
        ("浏览器数量", str(len(valid_browsers))),
        ("释放空间", f"{size_mb:.2f} MB"),
        ("模式", "预览" if preview else "实际执行")
    ])
    return total_size

def clean_recycle_bin(preview: bool = True) -> int:
    """清空回收站（美化输出）"""
    print_header("清理回收站")
    
    if preview:
        print_action("预览模式跳过回收站清理", "info")
        return 0
    
    try:
        print_action("正在清空回收站...", "info")
        winshell.recycle_bin().empty(confirm=False, show_progress=False, sound=False)
        print_action("回收站已清空", "success")
        return 0  # 无法计算回收站大小
    except Exception as e:
        print_action(f"清空回收站失败: {e}", "error")
        return 0

def clean_downloads(preview: bool = True) -> int:
    """清理下载目录（美化输出）"""
    print_header("清理下载目录")
    downloads_dir = Path.home() / 'Downloads'
    
    if not downloads_dir.exists():
        print_action("下载目录不存在", "warning")
        return 0
    
    print_section("扫描目录", f"[path]{downloads_dir}[/]")
    
    total_size = 0
    count = 0
    with print_progress_bar("扫描下载文件...") as progress:
        task = progress.add_task("清理中...", total=None)
        for item in downloads_dir.iterdir():
            if item.suffix.lower() in config.TEMP_EXTENSIONS:
                ok, size = safe_delete(item, preview)
                if ok:
                    total_size += size
                    count += 1
            progress.advance(task)
    
    size_mb = total_size / 1024 / 1024
    print_summary_table("下载目录清理结果", [
        ("删除文件数", str(count)),
        ("释放空间", f"{size_mb:.2f} MB"),
        ("模式", "预览" if preview else "实际执行")
    ])
    return total_size

def main(preview: bool = True, quiet: bool = False):
    """主函数（美化输出）"""
    print_header("Windows 垃圾清理工具")
    start_time = time.time()

    if not preview and not is_admin():
        require_admin()

    if not preview:
        if not quiet:
            print_section("警告", "即将实际删除文件，请确认!")
            confirm = console.input('[bold red]⚠️  确认实际删除文件? (y/n): [/]')
            if confirm.lower() != 'y':
                print_action("操作已取消", "warning")
                return

    total_size = 0
    total_size += clean_temp(preview)
    total_size += clean_browser_cache(preview)
    total_size += clean_recycle_bin(preview)
    total_size += clean_downloads(preview)

    elapsed = time.time() - start_time
    size_mb = total_size / 1024 / 1024
    size_gb = size_mb / 1024
    
    # 美化结果展示
    print_header("清理完成")
    print_summary_table("最终清理结果", [
        ("释放总空间", f"{size_mb:.2f} MB ({size_gb:.2f} GB)"),
        ("总耗时", f"{elapsed:.2f} 秒"),
        ("执行模式", "实际执行" if not preview else "预览")
    ])
    
    # 保存配置选项
    if not quiet and console.input('[bold]是否保存当前配置? (y/n): [/]').lower() == 'y':
        try:
            with open(config.CONFIG_FILE, 'w', encoding='utf-8') as f:
                json.dump(config.DEFAULT_CONFIG, f, indent=4)
            print_action(f"配置已保存到: {config.CONFIG_FILE}", "success")
        except Exception as e:
            print_action(f"保存配置失败: {e}", "error")

if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(description='Windows 垃圾清理工具 ')
    parser.add_argument('--run', action='store_true', help='真正执行清理（默认仅预览）')
    parser.add_argument('--debug', action='store_true', help='启用调试日志')
    parser.add_argument('--quiet', action='store_true', help='静默模式（无终端输出，只写日志）')
    args = parser.parse_args()

    init_logging(quiet=args.quiet)
    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)

    if not args.run and not args.quiet:
        print_section("信息", "运行在预览模式（不会实际删除文件）")
        print_action("使用 --run 参数执行实际删除操作", "info")

    try:
        main(preview=not args.run, quiet=args.quiet)
    except KeyboardInterrupt:
        print_action("操作已取消", "warning")
        sys.exit(0)
    except Exception as e:
        console.print_exception()
        sys.exit(1)
